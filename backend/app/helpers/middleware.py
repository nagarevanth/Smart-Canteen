from starlette.middleware.base import BaseHTTPMiddleware
from typing import Callable
from starlette.requests import Request
from starlette.responses import Response
from sqlalchemy.orm import Session

# Import the centralized utility for decoding tokens
from app.helpers.auth_utils import decode_token

# Import dependencies for database access
from app.core.database import get_db
from app.models.user import User

class AuthMiddleware(BaseHTTPMiddleware):
    """
    A custom authentication middleware that inspects the 'access_token' cookie
    to identify the current user and attach them to the request scope.
    """
    async def dispatch(
        self, request: Request, call_next: Callable[[Request], Response]
    ) -> Response:
        """
        The core logic of the middleware. This method is called for every request.

        Args:
            request: The incoming FastAPI request.
            call_next: A function to call to pass the request to the next
                       middleware or the actual path operation.

        Returns:
            The response generated by the application.
        """
        # Set a safe default: no user is authenticated.
        request.scope["user"] = None
        
        token = request.cookies.get("access_token")

        if token:
            # 1. Use our centralized utility to decode the token.
            payload = decode_token(token)
            
            if payload:
                user_id: str = payload.get("sub")
                
                # 2. CRITICAL: Manage the database session lifecycle manually.
                # Middleware runs before path operation dependency injection,
                # so we must handle the session here.
                db: Session = next(get_db())
                try:
                    # 3. Fetch the user from the database.
                    # Coerce to string to be robust against numeric IDs in tokens
                    user = db.query(User).filter(User.id == str(user_id)).first()
                    if user:
                        # 4. Attach the authenticated user object to the request scope.
                        # This makes `info.context["user"]` available in all GraphQL resolvers.
                        request.scope["user"] = user
                finally:
                    # 5. CRITICAL: Always close the database session to prevent connection leaks.
                    db.close()

        # Proceed to the next middleware or the actual GraphQL router.
        response = await call_next(request)
        return response